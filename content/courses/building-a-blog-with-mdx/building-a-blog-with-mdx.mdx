---
title: "Building a Blog with MDX"
description: "Learn how to treat content as data using Next.js, MDX, and Dynamic Routes."
difficulty: "Intermediate"
---

<Summary title="What we will build">

We are going to build a scalable blog engine where you write your posts in simple markdown files, and Next.js automatically turns them into beautiful, styled web pages. We will cover dynamic routing, reading files from your system, and rendering them safely.

</Summary>

## 1. The Problem: Hardcoded Pages

Without MDX, if you wanted to write 50 blog posts, you would have to manually create 50 different folders and 50 different `page.tsx` files.

`app/blog/post-1/page.tsx`

`app/blog/post-2/page.tsx`

`app/blog/post-3/page.tsx`

... and so on.

This is unmaintainable. If you wanted to change the title font size, you'd have to edit 50 files.

The solution is to separate **Content** (what you write) from **Structure** (how it looks). We write content in `.mdx` files and use one single template to display all of them.

## 2. Setting up MDX

MDX allows you to write standard Markdown (like you do in Notion or Obsidian) but also import React components directly into your writing.

First, we need a few packages to help Next.js read these files.

<CodeWindow title="Terminal" isTerminal>
  pnpm add next-mdx-remote gray-matter @tailwindcss/typography
</CodeWindow>

- **`next-mdx-remote`**: Allows us to render MDX content on the server (safely).
- **`gray-matter`**: Lets us add metadata to the top of our files (like Title, Date, Author) called "frontmatter".
- **`@tailwindcss/typography`**: A plugin that automatically styles your markdown (headers, bold text, lists) so you don't have to write CSS for every paragraph.

## 3. Architecture

We need a specific place to store our raw blog posts. We don't put them inside the `app/` folder because they aren't pages themselves; they are data.

We create a `content/` folder at the root of our project.

<RouteVisualizer
  files={[
    { type: 'folder', name: 'app', level: 0 },
    { type: 'folder', name: 'content', level: 0 },
    { type: 'file', name: 'hello-world.mdx', level: 1 },
    { type: 'file', name: 'nextjs-guide.mdx', level: 1 },
    { type: 'file', name: 'why-i-code.mdx', level: 1 },
  ]}
/>

Inside one of these files (`hello-world.mdx`), it looks like this:

<CodeWindow title="content/hello-world.mdx">

```mdx
---
title: "Hello World"
date: "2024-03-15"
description: "My first post on the new site."
---

# Welcome to my blog

This is a paragraph written in standard markdown.
```

</CodeWindow>

The part between the `---` dashes is the **Frontmatter**. That is the data we will read to display the title and date on your blog index.

## 4. Dynamic Routing

Now, how do we create one page that renders any of those files? We use a **Dynamic Segment**.

In Next.js, if you put square brackets around a folder name, it acts as a variable. We will create `app/blog/[slug]/page.tsx`.

<RouteVisualizer
  files={[
    { type: 'folder', name: 'app', level: 0 },
    { type: 'folder', name: 'blog', level: 1 },
    { type: 'folder', name: '[slug]', level: 2 },
    { type: 'file', name: 'page.tsx', level: 3 },
  ]}
  route="portfolio.com/blog/hello-world"
/>

When a user visits `/blog/hello-world`, Next.js grabs `"hello-world"`, puts it into a variable called `slug`, and passes it to our page. We then tell our code: "Go look in the content folder for a file named `hello-world.mdx`."

## 5. The Logic

Here is the simplified logic of how we read that file. We use Node.js's built-in file system (`fs`) module.

<CodeWindow title="lib/mdx.ts">

```ts
import fs from 'fs'
import path from 'path'
import matter from 'gray-matter'

const root = process.cwd()

export function getPost(slug: string) {
  const filePath = path.join(root, 'content', `${slug}.mdx`)
  const fileContent = fs.readFileSync(filePath, 'utf8')

  // separate metadata (frontmatter) from the actual content
  const { data, content } = matter(fileContent)

  return { metadata: data, content }
}
```

</CodeWindow>

This structure allows your blog to grow infinitely. You just add `.mdx` files to the folder, and they automatically exist as pages on your site.

## Prompt Section

Implementing a blog system involves a lot of boilerplate code (reading files, parsing dates, setting up types). Use this prompt to have Cursor build the entire engine for you in one go.

<PromptSection title="Copy this into Cursor">

```
# Role
You are a Senior Next.js Architect. You are an expert in Node.js `fs` (file system), MDX, and Server React Components.

# Objective
Create a fully functional, type-safe blog engine using MDX files as the data source.

# Tech Stack
- **Framework:** Next.js 16 (App Router)
- **Content:** MDX (via `next-mdx-remote`)
- **Metadata:** Gray-matter
- **Styling:** Tailwind CSS + Typography Plugin

# Instructions

## Step 1: Install Dependencies
Run the command to install necessary packages:
`pnpm add next-mdx-remote gray-matter @tailwindcss/typography`

## Step 2: Configure Tailwind
Update `tailwind.config.ts` to include the typography plugin `require('@tailwindcss/typography')`. This is critical for making the markdown look good (headings, paragraphs, lists) without manual styling.

## Step 3: Create Content Directory
1. Create a folder named `content` in the root directory.
2. Create two sample MDX files inside it:
   - `hello-world.mdx`: Include frontmatter (title, date, description) and some sample markdown content.
   - `architecture-guide.mdx`: Include a code block and a list in the markdown.

## Step 4: Create the MDX Utility
Create `lib/mdx.ts`. This file should export two functions:
1. `getPost(slug)`: Reads a specific file, parses frontmatter using `gray-matter`, and returns the data and raw content.
2. `getAllPosts()`: Reads the `content` directory, returns an array of all posts sorted by date (newest first).
*Constraint:* Ensure strict TypeScript typing for the "Frontmatter" object (title, date, description).

## Step 5: Create the Blog Index
Create `app/blog/page.tsx`.
- Fetch all posts using `getAllPosts()`.
- Display them in a grid using shadcn Cards (or clean Tailwind).
- Each card must link to `/blog/[slug]`.

## Step 6: Create the Dynamic Post Page
Create `app/blog/[slug]/page.tsx`.
- **generateStaticParams**: Use this function to statically generate routes for every file in `content` at build time (Crucial for performance).
- **Page Component**:
  - Call `getPost(params.slug)`.
  - Render the title and date.
  - Render the body using `<MDXRemote source={content} />`.
  - Wrap the content in a `<article className="prose prose-neutral lg:prose-xl">` div to activate the Tailwind Typography styling.

# Execution
Execute these steps sequentially. Do not ask for clarification unless a file path is ambiguous. Start by checking if `next-mdx-remote` is installed.
```

</PromptSection>
